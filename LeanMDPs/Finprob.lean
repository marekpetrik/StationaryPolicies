import Mathlib.Data.Nat.Basic
import Mathlib.Data.Real.Basic 
import Mathlib.Data.NNReal.Basic

import Mathlib.Data.Finset.Image
import Mathlib.Logic.Function.Defs 

import Mathlib.Data.Finsupp.Indicator


variable {œÑ : Type} 

open NNReal

---------------------- Indicator -----------------

/-- Boolean indicator function -/
@[reducible] 
def indicator (cond : Bool) : ‚Ñù := cond.rec 0 1
abbrev ùïÄ : Bool ‚Üí ‚Ñù := indicator

/-- Indicator is 0 or 1 -/
theorem ind_zero_one (cond : œÑ ‚Üí Bool) (œâ : œÑ) : 
  ((ùïÄ‚àòcond) œâ = 1) ‚à® ((ùïÄ‚àòcond) œâ = 0) := 
    if h : (cond œâ) then Or.inl (by simp only [Function.comp_apply, h, indicator])
    else Or.inr (by simp only [Function.comp_apply, h, indicator])

theorem ind_ge_zero (cond : œÑ ‚Üí Bool) (œâ : œÑ) : 0 ‚â§ (ùïÄ‚àòcond) œâ :=  by
  by_cases (cond œâ); simp_all [indicator]; simp_all [indicator]

---------- LSimplex Definitions  -----------------------------------------

section LSimplex

/-- states that p is a valid probability value -/
abbrev Prob (p : ‚Ñö) : Prop := 0 ‚â§ p ‚àß p ‚â§ 1

variable {p : ‚Ñö}

@[simp]
theorem Prob.of_complement (h1 : Prob p) : Prob (1-p) := by aesop

@[simp]
theorem Prob.complement_inv_nneg (h1 : Prob p) : 0 ‚â§ (1-p)‚Åª¬π := by aesop

def List.scale (L : List ‚Ñö) (c : ‚Ñö) : List ‚Ñö := (L.map fun x‚Ü¶x*c)

/-- Self-normalizing list of probabilities  --/
structure LSimplex (L : List ‚Ñö) : Prop where
  nneg : ‚àÄp ‚àà L, 0 ‚â§ p               -- separate for convenience
  normalized : L.sum = 1             -- sums to 1
  
def LSimplex.singleton : LSimplex [1] := 
  ‚ü®fun p a => by simp_all only [List.mem_cons, List.not_mem_nil, or_false, zero_le_one], 
    List.sum_singleton‚ü©

variable {L : List ‚Ñö}  {c : ‚Ñö}

/-- cannot define a simplex on an empty set -/
@[simp]
theorem LSimplex.nonempty (S : LSimplex L) : L ‚â† [] := 
        fun a => by have := S.normalized; simp_all 
       
@[simp] 
abbrev LSimplex.npt : LSimplex L ‚Üí L ‚â† [] := LSimplex.nonempty

def LSimplex.phead (h : LSimplex L) : ‚Ñö := L.head h.nonempty

/-- all probability in the head element -/
def LSimplex.degenerate (S : LSimplex L) : Bool := S.phead  == 1

@[simp]
theorem LSimplex.mem_prob (h1 : LSimplex L) : ‚àÄ p ‚àà L, Prob p := 
  fun p a => ‚ü® h1.nneg p a, 
               h1.normalized ‚ñ∏ List.single_le_sum h1.nneg p a‚ü©
               
theorem LSimplex.phead_inpr (S : LSimplex L) : S.phead ‚àà L := List.head_mem S.nonempty

@[simp]
theorem LSimplex.phead_prob (S : LSimplex L) : Prob S.phead := S.mem_prob S.phead S.phead_inpr
               
theorem LSimplex.phead_nongen (S : LSimplex L) (nongen : ¬¨S.degenerate) : S.phead  < 1 :=
  by simp [degenerate] at nongen
     exact lt_of_le_of_ne S.phead_prob.2 nongen 

theorem LSimplex.degenerate_head_lt (S : LSimplex L) (nond : ¬¨S.degenerate) : L.head S.npt < 1 :=
    by have prob := LSimplex.mem_prob S (L.head S.npt) (List.head_mem (LSimplex.npt S))
       simp [LSimplex.degenerate] at nond              
       simp [Prob] at prob             
       exact lt_of_le_of_ne prob.2 nond

@[simp]
theorem List.scale_sum : (L.scale c).sum = c * L.sum := 
  by induction L
     ¬∑ simp [List.scale]
     ¬∑ simp_all [List.scale]
       ring

@[simp]
theorem List.scale_length : (L.scale c).length = L.length := by simp [List.scale]

theorem List.scale_nneg_of_nneg (h : ‚àÄl ‚àà L, 0 ‚â§ l) (h1 : 0 ‚â§ c) : (‚àÄl ‚àà L.scale c, 0 ‚â§ l) := 
  by induction L 
     ¬∑ simp [List.scale]
     ¬∑ simp_all [List.scale]
       exact Left.mul_nonneg h.1 h1
  
theorem List.append_nneg_of_nneg (h : ‚àÄl ‚àà L, 0 ‚â§ l) (h1 : 0 ‚â§ p) : (‚àÄl ‚àà p::L, 0 ‚â§ l) := 
  by aesop

/-- adds a new probability to a list and renormalizes the rest --/
def List.grow (L : List ‚Ñö) (p : ‚Ñö) : List ‚Ñö := p :: (L.scale (1-p)) 
    
theorem List.grow_sum : (L.grow p).sum = L.sum * (1-p) + p := 
  by induction L
     ¬∑ simp [List.grow, List.scale]
     ¬∑ simp [List.grow, List.scale_sum]
       ring

@[simp]
theorem List.grow_ge0 (h1 : ‚àÄl ‚àà L, 0 ‚â§ l)  (h2 : Prob p) :  ‚àÄ l ‚àà (L.grow p), 0 ‚â§ l := 
    by simp [List.grow]
       constructor
       ¬∑ exact h2.1
       ¬∑ intro l a
         exact List.scale_nneg_of_nneg 
               (L := L) (c := (1-p)) h1 (Prob.of_complement h2).1 l a

-- grows the simplex to also incude the probability p
@[simp]
theorem LSimplex.grow (S : LSimplex L) {p : ‚Ñö} (prob : Prob p) : LSimplex (L.grow p) :=
  {nneg := List.grow_ge0 S.nneg prob,
   normalized := by simp [List.grow_sum, S.normalized]}

/-- Removes head and rescales -/
def List.shrink : List ‚Ñö ‚Üí List ‚Ñö
    | nil => nil
    | head :: tail => tail.scale (1-head)‚Åª¬π
    
@[simp]
theorem List.shrink_length : L.shrink.length = L.tail.length := 
  by cases L; simp [List.shrink]; simp[List.shrink, List.scale]
    
@[simp]
theorem List.shrink_sum (npt: L ‚â† []) (h : L.head npt < 1) : 
        (L.shrink).sum = (L.tail).sum / (1 - L.head npt)  := 
        by cases L; contradiction; simp_all [List.shrink, List.scale_sum]; ring

theorem List.shrink_ge0 (h1 : ‚àÄl ‚àà L, Prob l) : ‚àÄl ‚àà (L.shrink), 0 ‚â§ l := 
    by simp [List.shrink]
       cases L with
       | nil => simp_all only [List.not_mem_nil, IsEmpty.forall_iff, implies_true]
       | cons head tail => 
           simp_all [Prob.complement_inv_nneg]
           have hh : 0 ‚â§ (1-head)‚Åª¬π := Prob.complement_inv_nneg h1.1
           exact List.scale_nneg_of_nneg (L:=tail) (c:=(1-head)‚Åª¬π) (fun l a ‚Ü¶ (h1.2 l a).1) hh 
         
variable {L : List ‚Ñö}

lemma false_of_p_comp1_zero_p_less_one (h1 : 1 - p = 0) (h2 : p < 1) : False := by linarith
  
@[simp]
theorem LSimplex.tail_sum (S : LSimplex L) : L.tail.sum = (1 - L.head S.npt) := 
  by cases L; have := S.npt; contradiction; have := S.normalized; simp at this ‚ä¢; linarith

theorem LSimplex.shrink (S : LSimplex L) (h : ¬¨ S.degenerate) : LSimplex (L.shrink) :=
  {nneg := List.shrink_ge0 (LSimplex.mem_prob S),
   normalized := 
     by have npt := S.npt
        have hh := LSimplex.degenerate_head_lt S h
        have hh1 := S.tail_sum 
        have hh2 : (1 - L.head npt) ‚â† 0 := by linarith
        rw[List.shrink_sum S.npt hh]
        exact (div_eq_one_iff_eq hh2).mpr hh1}
        
theorem List.grow_of_shrink 
        (S : LSimplex L) (nongen : ¬¨ S.degenerate) : L = (L.shrink).grow (S.phead) := 
   by induction L with
      | nil => have := S.nonempty; contradiction 
      | cons head tail => 
             let h : (1-head) ‚â† 0 := 
               fun a => false_of_p_comp1_zero_p_less_one a (S.phead_nongen nongen)
             simp_all [List.grow, List.shrink, List.scale, LSimplex.phead]

-- all props of the same type are equal
theorem LSimplex.grow_of_shrink (S : LSimplex L) (nongen : ¬¨S.degenerate) : 
        S = (List.grow_of_shrink S nongen) ‚ñ∏ (S.shrink nongen).grow S.phead_prob := rfl
             
end LSimplex

-----------------   Section FinDist ----------------------------------------------------
section FinDist

/-- Finite probability distribution on a set-like list (non-duplicates) -/
structure Findist (Œ© : List œÑ) (pr : List ‚Ñö) : Prop where
  simplex : LSimplex pr            -- proof of a measure
  unique : Œ©.Nodup                 -- Œ© are unique
  lmatch : pr.length = Œ©.length    -- lengths are the same
  
abbrev Delta : List œÑ ‚Üí List ‚Ñö ‚Üí Prop := Findist
abbrev Œî : List œÑ ‚Üí List ‚Ñö ‚Üí Prop := Delta

variable {Œ© : List œÑ} {pr : List ‚Ñö}
variable (F : Findist Œ© pr) 

abbrev Findist.degenerate : Bool := F.simplex.degenerate

/-- add a new head -/
def Findist.grow {p : ‚Ñö} {œâ : œÑ} (prob : Prob p)  (notin : œâ ‚àâ Œ©) : Findist (œâ :: Œ©) (pr.grow p) :=
    {simplex := F.simplex.grow prob, 
     unique := by simp_all [F.unique],
     lmatch := by simp [List.grow, List.scale_length, F.lmatch]}

/-- if nondegenenrate then construct a tail distribution -/
def Findist.shrink (h : ¬¨F.simplex.degenerate) : Findist (Œ©.tail) (pr.shrink) :=
    let pr' := pr.shrink 
    let hl : pr'.length = pr.length - 1 := 
        by rw [List.shrink_length (L:=pr)]; exact List.length_tail 
    {simplex := F.simplex.shrink h 
     unique := by have := F.unique; cases Œ©; simp; simp_all
     lmatch := by simp [hl, F.lmatch]}

def Findist.singleton (t : œÑ) : Findist [t] [1] := 
    {simplex := LSimplex.singleton,
      unique := List.nodup_singleton t,
      lmatch := by simp_all only [List.length_cons, List.length_nil, zero_add]}

@[simp]
theorem Findist.nonempty_Œ© (F : Findist Œ© pr) : Œ© ‚â† [] :=
  by have h1 := F.lmatch
     have h2 := F.simplex.npt  
     intro a; simp_all only [List.length_nil, List.length_eq_zero_iff]

@[simp]
theorem Findist.nonempty_P (F : Findist Œ© pr) : pr ‚â† [] :=
  by have := F.simplex.npt
     intro a; contradiction
          
abbrev Findist.œâhead := Œ©.head F.nonempty_Œ©

abbrev Findist.phead := pr.head F.nonempty_P

--example (a : Prop) (b : Prop) : ¬¨(a ‚àß b) = (¬¨ a) ‚à® (¬¨b) := 

@[simp]
theorem Findist.phead_inpr : F.phead ‚àà pr := List.head_mem F.nonempty_P

@[simp]
theorem Findist.phead_prob : Prob F.phead := F.simplex.mem_prob F.phead F.phead_inpr

theorem Findist.œâhead_notin_tail : Œ©.head F.nonempty_Œ© ‚àâ Œ©.tail := 
  by have := F.nonempty_Œ©
     cases Œ©
     ¬∑ contradiction
     ¬∑ exact List.Nodup.notMem F.unique

theorem Findist.nondegenerate_head (nongen : ¬¨F.degenerate) : F.phead < 1 := 
  by have h1 := Findist.phead_prob F
     simp_all only [degenerate, LSimplex.degenerate, LSimplex.phead, beq_iff_eq, phead, gt_iff_lt]
     --unfold Prob at h1
     exact lt_of_le_of_ne h1.2 nongen

theorem Findist.Œ©_eq_headtail : F.œâhead :: Œ©.tail = Œ© :=  
  by simp_all only [List.head_cons_tail]

theorem pr_eq_headtail (nongen : ¬¨F.degenerate) : pr.shrink.grow F.phead = pr:= 
  by symm
     simp [Findist.degenerate] at nongen 
     exact List.grow_of_shrink F.simplex (ne_true_of_eq_false nongen) 

-- For the use of ‚ñ∏ see: https://proofassistants.stackexchange.com/questions/1380/how-do-i-convince-the-lean-4-type-checker-that-addition-is-commutative
      
-- TODO: the manipulation below seems excessive; there must be a better way
def Findist.growshrink (nongen : ¬¨F.degenerate) : Findist Œ© pr := 
    let Z := pr.shrink.grow F.phead
    let A : Findist (F.œâhead :: Œ©.tail) Z := 
            (F.shrink nongen).grow F.phead_prob F.œâhead_notin_tail 
    let B : Findist Œ© Z := F.Œ©_eq_headtail ‚ñ∏ A
    (pr_eq_headtail F nongen) ‚ñ∏ B
    
theorem Findist.typesame_all_same {Œ©‚ÇÅ Œ©‚ÇÇ : List œÑ} {P‚ÇÅ P‚ÇÇ : List ‚Ñö}
  (h1 : Œ©‚ÇÅ = Œ©‚ÇÇ) (h2 : P‚ÇÅ = P‚ÇÇ)  : Findist Œ©‚ÇÅ P‚ÇÅ = Findist Œ©‚ÇÇ P‚ÇÇ :=  h1 ‚ñ∏ h2 ‚ñ∏ rfl
  
-- probably not needed
theorem Findist.typesame_all_same2 {Œ©‚ÇÅ Œ©‚ÇÇ : List œÑ} {P‚ÇÅ P‚ÇÇ : List ‚Ñö}
  (h1 : Œ©‚ÇÅ = Œ©‚ÇÇ) (h2 : P‚ÇÅ = P‚ÇÇ) (f1 : Findist Œ©‚ÇÅ P‚ÇÅ) (f2 : Findist Œ©‚ÇÇ P‚ÇÇ) : 
f1 = ((Findist.typesame_all_same h1 h2) ‚ñ∏ f2) := rfl

theorem Findist.grow_of_shrink (nongen : ¬¨F.degenerate) : 
  F.growshrink nongen = F :=
    by let G := (F.shrink nongen).grow F.phead_prob F.œâhead_notin_tail
       have h1 : ¬¨ F.simplex.degenerate := by simp_all 
       simp [grow, List.grow, growshrink]
       
end FinDist

-------------------------- Section Finprob ------------------------------------------------------
section Finprob

/-- Finite probability space -/
structure Finprob (œÑ : Type) : Type where
  Œ© : List œÑ       
  ‚Ñô : List ‚Ñö
  prob : Findist Œ© ‚Ñô

variable (P : Finprob œÑ)

def Finprob.singleton (œâ : œÑ) : Finprob œÑ := 
   ‚ü® [œâ], [1], Findist.singleton œâ ‚ü©

def Finprob.grow {p : ‚Ñö} {œâ : œÑ} (prob : Prob p)  (notin : œâ ‚àâ P.Œ©) : Finprob œÑ :=
  ‚ü®œâ :: P.Œ©, P.‚Ñô.grow p, P.prob.grow prob notin‚ü©
  
/-- all probability in the head -/
abbrev Finprob.degenerate (P : Finprob œÑ) : Bool := P.prob.simplex.degenerate

def Finprob.shrink (notd : ¬¨P.degenerate) : Finprob œÑ := 
  { Œ© := P.Œ©.tail, ‚Ñô := P.‚Ñô.shrink, prob := P.prob.shrink notd}
    
def Finprob.length := P.Œ©.length 

-- Define an induction principle for probability spaces
-- similar to the induction on lists, but also must argue about probability distributions

theorem Finprob.nonempty  : ¬¨P.Œ©.isEmpty := 
  by have := LSimplex.nonempty P.prob.simplex; have := P.prob.lmatch
     intro a; simp_all only [ne_eq, List.isEmpty_iff, List.length_nil, List.length_eq_zero_iff]

theorem Finprob.nonempty_Œ© : P.Œ© ‚â† [] := fun E => P.nonempty (E ‚ñ∏ List.isEmpty_nil)

theorem Finprob.nonempty_P : P.‚Ñô ‚â† [] := P.prob.simplex.nonempty
          
def Finprob.œâhead := P.Œ©.head P.nonempty_Œ©

def Finprob.phead := P.‚Ñô.head P.nonempty_P

theorem Finprob.œâhead_notin_tail: P.œâhead ‚àâ P.Œ©.tail := Findist.œâhead_notin_tail P.prob

theorem Finprob.phead_inpr : P.phead ‚àà P.‚Ñô := List.head_mem P.nonempty_P
    
theorem Finprob.phead_prob : (Prob P.phead) := 
  P.prob.simplex.mem_prob P.phead P.phead_inpr

theorem Finprob.len_ge_one : 1 ‚â§ P.length := 
  by have := nonempty P; simp_all [Finprob.length]
     generalize P.Œ© = L at this ‚ä¢
     cases L; simp_all; simp_all

theorem Finprob.tail_tail (notd : ¬¨P.prob.simplex.degenerate) : (P.shrink notd).Œ© = P.Œ©.tail := 
  by simp_all only [Finprob.shrink]
        
lemma List.unique_head_notin_tail (L : List œÑ) (ne : L ‚â† []) (nodup : L.Nodup) : 
      L.head ne ‚àâ L.tail := 
  by induction L
     ¬∑ simp at ne 
     ¬∑ simp [List.head, List.tail]
       simp_all only [ne_eq, reduceCtorEq, not_false_eq_true, List.nodup_cons]

theorem Finprob.head_notin_tail (P : Finprob œÑ) : (P.Œ©.head (Finprob.nonempty_Œ© P)) ‚àâ P.Œ©.tail := by 
  have := P.prob.unique
  apply List.unique_head_notin_tail
  simp_all only [ne_eq]
 

theorem Finprob.shrink_shorter (notd : ¬¨P.prob.simplex.degenerate) : 
                                 (P.shrink notd).length = P.length - 1 :=
        by simp_all only [Finprob.shrink, Finprob.length, List.length_tail]
  
/-- Shows that growing an shrink probability will create the same probability space -/ 
theorem Finprob.grow_of_shrink 
     (nongen : ¬¨P.degenerate) : P = (P.shrink nongen).grow P.phead_prob P.œâhead_notin_tail := 
    by rw [Finprob.mk.injEq] -- same fields equivalent to same structures
       simp [Finprob.shrink, Finprob.grow, Findist.shrink, Findist.grow,œâhead]
       apply List.grow_of_shrink
       simp_all [Finprob.degenerate]
       exact P.prob.simplex
       

------- Section Finprob Induction ----------------------------------------------------------

/-- induction principle for finite probabilities -/
def Finprob.elim.{u} {motive : Finprob œÑ ‚Üí Sort u} 
        (degenerate :  (fp : Finprob œÑ) ‚Üí (d : fp.degenerate) ‚Üí motive fp)
        (composite : (tail : Finprob œÑ) ‚Üí (œâ : œÑ) ‚Üí (notin : œâ ‚àâ tail.Œ©) ‚Üí 
                (p : ‚Ñö) ‚Üí (inP : Prob p) ‚Üí (motive tail) ‚Üí motive (tail.grow inP notin)) 
        (P : Finprob œÑ) : motive P := 
    if b1 : P.‚Ñô = [] then
      by have := LSimplex.nonempty P.prob.simplex; simp_all
    else
      if b2 : P.degenerate then
        degenerate P b2
      else
        let tail := P.shrink b2
        let ih : motive tail := Finprob.elim  degenerate composite tail 
        let growshrink := Finprob.grow_of_shrink P b2
        let final := composite tail P.œâhead P.œâhead_notin_tail P.phead P.phead_prob ih
        sorry   
    termination_by P.length
    decreasing_by 
      simp [Finprob.shrink, Finprob.length]
      apply Finprob.len_ge_one
    
end Finprob

------------------------------ Section Finrv -----------------------------------

section Finrv

/-- Random variable defined on a finite probability space -/
structure Finrv (P : Finprob œÑ) (œÅ : Type) : Type  where
  val : œÑ ‚Üí œÅ   -- actual value of the random variable

end Finrv
